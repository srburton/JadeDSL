using JadeDSL.Core;
using JadeDSL.Core.Types;
using Xunit;

namespace JadeDSL.Tests
{
    public class VulnerabilityTests
    {
        private readonly Parser parser;
        private readonly Options options = new() { MaxNodeCount = 100 };

        public VulnerabilityTests()
        {
            parser = new Parser(options);
        }

        [Theory]
        [InlineData("name")]
        [InlineData("name:")]
        [InlineData("name:>")]
        [InlineData("name:!=")]
        [InlineData("name:==")]
        public void Should_Throw_InvalidOperationException_On_InvalidFilterExpression(string expr)
        {
            var tokens = Tokenizer.Tokenize(expr);
            Assert.Throws<InvalidOperationException>(() => parser.Parse(tokens));
        }

        [Fact]
        public void Should_Throw_InvalidOperationException_When_Exceeding_MaxNodeCount()
        {
            var tokens = new List<Token>();
            for (int i = 0; i < options.MaxNodeCount + 1; i++)
            {
                tokens.Add(new Token { Type = TokenType.Expression, Value = $"field{i}:value" });
                if (i < options.MaxNodeCount)
                    tokens.Add(new Token { Type = TokenType.And });
            }

            Assert.Throws<InvalidOperationException>(() => parser.Parse(tokens));
        }

        [Theory]
        [InlineData("name:\"Renato\"&")]
        [InlineData("name:\"Renato\"|")]
        [InlineData("()")]
        public void Should_Throw_Exception_On_SyntaxErrors(string expression)
        {
            var tokens = Tokenizer.Tokenize(expression);
            Assert.ThrowsAny<InvalidOperationException>(() => parser.Parse(tokens));
        }

        [Theory]
        [InlineData("(name:\"Renato\"|age")]
        [InlineData("(name:\"Renato\"&age>30")]
        [InlineData("name:\"\" OR 1=1 --\"")]
        public void Should_Throw_InvalidOperationException_On_PotentialInjectionLikePatterns(string expression)
        {
            Assert.Throws<InvalidOperationException>(() => Tokenizer.Tokenize(expression));
        }

        [Theory]
        [InlineData("name:\"eval('evil()')\"")]
        [InlineData("name:\"test\"; System.Diagnostics.Process.Start('calc')")]
        public void Should_Throw_InvalidOperationException_On_PotentialInjectionLikePatterns2(string expression)
        {
            var tokens = Tokenizer.Tokenize(expression);
            Assert.Throws<InvalidOperationException>(() => parser.Parse(tokens));
        }

        [Theory]
        [InlineData("((((abc:foo))")]
        [InlineData("abc:foo))")]
        [InlineData("((abc:foo)")]
        [InlineData("\"abc:foo")]
        [InlineData("((((")]
        [InlineData("))))")]
        public void Should_Throw_On_Unbalanced_Parentheses(string input)
        {
            // For now, tokenizer doesn't validate balance, but parser will
            Assert.ThrowsAny<InvalidOperationException>(() => Tokenizer.Tokenize(input));
        }

        [Fact]
        public void Should_Throw_On_Deeply_Nested_Expressions()
        {
            var deep = string.Concat(Enumerable.Repeat("(", 150)) +
                       "age:30" +
                       string.Concat(Enumerable.Repeat(")", 150));

            var tokens = Tokenizer.Tokenize(deep);
            Assert.Throws<InvalidOperationException>(() => parser.Parse(tokens));
        }

        [Theory]
        [InlineData("name:\":\"")]
        [InlineData("name:\"==\"")]
        [InlineData("name:\"<=\"")]
        [InlineData("name:\">=\"")]
        public void Should_Throw_When_Value_Contains_Symbol_As_Prefix(string expression)
        {
            var tokens = Tokenizer.Tokenize(expression);
            Assert.Throws<InvalidOperationException>(() => parser.Parse(tokens));
        }
    }
}
